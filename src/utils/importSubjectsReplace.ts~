import * as Papa from "papaparse";
import { parseDateFromCell, normalizeQuad, normalizeCursAny, makeSubjectKey } from "./csvHelpers";
import type {
  Subject,
  Period,
  SlotsPerPeriod,
  AssignedPerPeriod,
  RoomsDataPerPeriod,
} from "../types/examPlanner";

/**
 * Importa assignatures + períodes (REPLACE)
 * Retorna: { subjects, periods, slotsPerPeriod, assignedPerPeriod, roomsData, allowedPeriodsBySubject }
 */
export function importSubjectsReplace(csvText: string) {
  const parsed = Papa.parse(csvText, { header: true });
  const rows = parsed.data as any[];

  const subjByKey = new Map<string, Subject>();
  const periodsById = new Map<number, Period>();
  const slotsMap: SlotsPerPeriod = {};
  const allowedPeriods: Record<string, number[]> = {};

  for (const r of rows) {
    // --- 1. SUBJECTES ---
    const codi = r.codi ?? r.codigo ?? r.CODI ?? r.CODIGO ?? r.code;
    const sigles = r.sigles ?? r.SIGLES ?? r.siglas ?? r.SIGLAS;
    const nivell = (r.nivell ?? r.NIVELL ?? r.nivel ?? r.NIVEL)?.toString();

    const curs = normalizeCursAny(r.curs ?? r.CURS ?? r.curso ?? r.CURSO);
    const quadrimestre = normalizeQuad(r.quadrimestre ?? r.QUADRIMESTRE ?? r.quad ?? r.QUAD);

    const MET = r.MET ?? r.met;
    const MATT = r.MATT ?? r.matt;
    const MEE = r.MEE ?? r.mee;
    const MCYBERS = r.MCYBERS ?? r.mcybers;

    if (codi || sigles) {
      const key = makeSubjectKey(codi, sigles);

      if (!subjByKey.has(key)) {
        subjByKey.set(key, {
          id: String(codi || sigles),
          codi: String(codi || ""),
          sigles: String(sigles || ""),
          nivell: nivell || undefined,
          curs: curs || undefined,
          quadrimestre,
          MET: MET ? String(MET) : undefined,
          MATT: MATT ? String(MATT) : undefined,
          MEE: MEE ? String(MEE) : undefined,
          MCYBERS: MCYBERS ? String(MCYBERS) : undefined,
        });
      }
    }

    // --- 2. PERÍODES ---
    const pidRaw = r.period_id ?? r.PERIOD_ID ?? r.pid ?? r.PID;
    const pid = pidRaw ? Number(pidRaw) : NaN;
    if (Number.isFinite(pid) && pid >= 1) {
      const label = `Període ${pid}`;
      const tipusRaw = (r.period_tipus ?? r.PERIOD_TIPUS ?? r.tipo ?? r.TIPO ?? "").toString().toUpperCase();

      const tipus = tipusRaw === "FINAL"
        ? "FINAL"
        : ["REAVALUACIO","REAVALUACIÓ","REAVALUACION"].includes(tipusRaw)
          ? "REAVALUACIÓ"
          : "PARCIAL";

      const startStr = parseDateFromCell(r.period_inici ?? r.PERIOD_INICI ?? r.start);
      const endStr   = parseDateFromCell(r.period_fi    ?? r.PERIOD_FI    ?? r.end);

      if (!periodsById.has(pid)) {
        periodsById.set(pid, {
          id: pid,
          label,
          tipus,
          startStr: startStr || "",
          endStr: endStr || "",
          curs: undefined,
          quad: undefined,
          blackouts: [],
        });

        slotsMap[pid] = [{ start: "08:00", end: "10:00" }];
      }
    }
  }

  return {
    subjects: Array.from(subjByKey.values()),
    periods: Array.from(periodsById.values()),
    slotsPerPeriod: slotsMap,
    assignedPerPeriod: {} as AssignedPerPeriod,
    roomsData: {} as RoomsDataPerPeriod,
    allowedPeriodsBySubject: allowedPeriods,
  };
}

